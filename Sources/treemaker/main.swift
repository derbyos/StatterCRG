//
//  main.swift
//  treemaker
//
//  Created by gandreas on 7/21/23.
//

import Foundation

var inputFileName : String
var outputFolder: String

if CommandLine.arguments.count < 2 {
    inputFileName = "/Users/gandreas/Sources/Statter/treemaker/TreeDefinition"
    outputFolder = "/Users/gandreas/Sources/Statter/Statter/GenTree"
} else {
    guard CommandLine.arguments.count == 3 else {
        fatalError()
    }
    inputFileName = CommandLine.arguments[1]
    outputFolder = CommandLine.arguments[2]
}

class AST {
    enum Kind : Equatable {
        case root
        case node(parent: String?)
        case leaf(String)
        case `var`
        case key(String)
        case comment // stored in name
        case code // pass through verbatim
        case `enum`
        case `case`(String?)
        case `subscript`(String)
        case action
    }
    var kind: Kind
    var name: String
    var children: [AST]
    init(kind: Kind, name: String) {
        self.kind = kind
        self.name = name
        children = []
    }
}

struct Document {
    var roots: [AST]
    var symbols: [String: AST]
}

enum Errors : Error {
    case syntaxError
    case missingNodeName
    case missingLeafType
    case rootNodeNotAtRoot
    case multipleNodeKeys
}

let indentBy = "    "

extension String {
    var initialLowercase: String {
        guard self.isEmpty == false else {
            return self
        }
        return self.first!.lowercased() + self.dropFirst()
    }
    func asPathParam(_ base: String, name: String) -> String {
        switch self {
        case "UUID", "UUID?":
            return ".id(\"\(base)\", id: \(name))"
        case "Int", "Int?":
            return ".number(\"\(base)\", param: \(name))"
        case "String", "String?":
            return ".name(\"\(base)\", name: \(name))"
        default:
            return ".name(\"\(base)\", name: \(name).rawValue)"
        }
    }
}
extension AST {
    var key: AST? {
        children.first(where: {
            if case .key = $0.kind {
                return true
            }
            return false
        })
    }
    var keyType: String? {
        if case let .key(type) = kind {
            return type
        }
        return nil
    }
    func generate() throws -> String {
//        guard kind == .root else {
//            throw Errors.rootNodeNotAtRoot
//        }
        var fileSrc = """
// \(name).swift
// Statter
//
// This file auto-generated by treemaker, do not edit
//

import Foundation

"""
        fileSrc.append(try generate(parent: "", indent: "").joined(separator: "\n") + "\n")
        return fileSrc
    }
    
    func save(destURL: URL) throws {
//        guard kind == .root else {
//            throw Errors.rootNodeNotAtRoot
//        }
        switch kind {
        case .comment, .var:
            return // do nothing with these in top level
        default:
            let fileURL = destURL.appending(path: "\(name).swift")
            let fileSrc = try generate()
            try fileSrc.data(using: .utf8)?.write(to: fileURL)
        }
    }
    
    func generate(parent: String, indent: String) throws -> [String] {
        var lines : [String]
        switch kind {
        case .comment, .code:
            return [indent + name + "\n"]
        case .enum:
            lines = [
                "public enum \(name): String {",
            ]
        case .`case`(let value):
            return [indent + "case \(name.initialLowercase) = \"\(value ?? name)\""]
        case .action:
            return [indent + "public func \(name.initialLowercase)() { connection.set(key: statePath.adding(\"\(name)\"), value: .bool(true), kind: .action) }"]
        case .root:
            lines = [
                "public struct \(name) : PathSpecified {",
                indentBy + "public var connection: Connection",
                indentBy + "public var statePath: StatePath { .init(components: [.plain(\"\(name)\")])}",
                "",
            ]
        case .node(let parent2):
            let fullParent = parent2 ?? parent
            let qname: String
            let qparent: String
            if fullParent.contains(" ") { // it is a template
                qname = name + "<P:PathSpecified>"
                qparent = "P"
            } else if fullParent.hasSuffix(">") {
                qname = name + "<P:PathSpecified>"
                qparent = fullParent
            } else {
                qname = name
                qparent = fullParent
            }
            lines = [
                "public struct \(qname) : PathNode {",
                indentBy + "public var parent: \(qparent)"
            ]
            // state path can either be plain, or some sort of parameter (or an optional one)
            if let key, let keyType = key.keyType {
                if keyType.hasSuffix("?") {
                    lines += [
                        indentBy + "public var statePath: StatePath {",
                        indentBy + indentBy + "if let \(key.name) {",
                        indentBy + indentBy + indentBy + "return parent.adding(\(keyType.asPathParam(name, name: key.name.initialLowercase)))",
                        indentBy + indentBy + "} else {",
                        indentBy + indentBy + indentBy + "return  parent.adding(.wild(\"\(name)\"))",
                        indentBy + indentBy + "}",
                        indentBy + "}",
                        "",
                    ]
                } else {
                    lines += [
                        indentBy + "public var statePath: StatePath { parent.adding(\(keyType.asPathParam(name, name: key.name.initialLowercase)))}",
                        "",
                    ]
                }
            } else {
                lines += [
                    indentBy + "public var statePath: StatePath { parent.adding(.plain(\"\(name)\"))}",
                    "",
                ]
            }
        case .leaf(let type):
            return [indent + "@Leaf public var \(name.initialLowercase): \(type)?\n"]
        case .subscript(let type):
            return [
                indent + "struct \(name)_Subscript {",
                indent + indentBy + "var connection: Connection",
                indent + indentBy + "var statePath: StatePath",
                indent + indentBy + "subscript(\(name.initialLowercase):\(name)) -> \(type)? {",
                indent + indentBy + indentBy + "let l = Leaf<\(type)>(connection: connection, component: .name(\"\(name)\", name: \(name.initialLowercase).rawValue), parentPath: statePath)",
                indent + indentBy + indentBy + "return l.wrappedValue",
                indent + indentBy + "}",
                indent + "}",
                indent + "var \(name.initialLowercase):\(name)_Subscript { .init(connection: connection, statePath: statePath) }"
            ]
        case .key(let type):
            return [indent + "public var \(name.initialLowercase) : \(type)\n"]
        case .var:
            return [indent + "public var \(name.initialLowercase) : \(name) { .init(parent: self) }\n"]
        }
        // now the children
        for child in children {
            lines.append(contentsOf: try child.generate(parent: name, indent: indentBy))
        }
        // now any additional init
        switch kind {
        case .enum:
            lines.append("}")
        case .node(let parent2):
            let fullParent = parent2 ?? parent
            var parameters = ""
            if let key = self.key, let keyType = key.keyType {
                parameters = ", \(key.name.initialLowercase): \(keyType)"
                if keyType.hasSuffix("?") {
                    parameters.append(" = nil")
                }
            }
            let qparent: String
            if fullParent.contains(" ") {
                qparent = "P"
            } else {
                qparent = fullParent
            }
            lines.append(indentBy + "public init(parent: \(qparent)\(parameters)) {")
            lines.append(indentBy + indentBy + "self.parent = parent")
            if let key = self.key {
                lines.append(indentBy + indentBy + "self.\(key.name.initialLowercase) = \(key.name.initialLowercase)")
            }
            // the leaf really needs to be `self.leaf("Name")` but
            // we can't use that until it is set, so two passes
            for child in children {
                switch child.kind {
                case .leaf(_):
                    lines.append(indentBy + indentBy + "_\(child.name.initialLowercase) = parent.leaf(\"\(child.name)\")")
                default:
                    break
                }
            }
            for child in children {
                switch child.kind {
                case .leaf(_):
                    lines.append(indentBy + indentBy + "_\(child.name.initialLowercase).parentPath = statePath")
                default:
                    break
                }
            }
            lines.append(indentBy + "}")
            lines.append("}")
            // the declaration in the parent (either in this file or at the root as an extension)
            func addParentVar(indent: String = "", parent: String = "") {
                if let key, let keyType = key.keyType {
                    let qualified = keyType == "Kind" ? "\(name).Kind" : keyType
                    let defaultValue = keyType.hasSuffix("?") ? " = nil" : ""
                    lines.append("\(indent)public func \(name.initialLowercase)(_ \(key.name.initialLowercase): \(qualified)\(defaultValue)) -> \(name)\(parent) { .init(parent: self, \(key.name.initialLowercase): \(key.name.initialLowercase)) }")
                } else {
                    lines.append("\(indent)public var \(name.initialLowercase): \(name)\(parent) { .init(parent: self) }")
                }
            }
            if let parent2 {
                for aParent in parent2.components(separatedBy: " ") {
                    let qparent : String
                    if aParent.hasSuffix(">") {
                        qparent = aParent.split(separator: "<").first.flatMap{String($0)}!
                    } else {
                        qparent = aParent
                    }
                    lines += [ "extension \(qparent) {"]
                    if parent2.contains(" ") {
                        // needs to qualify this
                        addParentVar(indent: indentBy, parent: "<\(qparent)>")
                    } else if parent2.hasSuffix(">") {
                        // needs to qualify this
                        addParentVar(indent: indentBy, parent: "<P>")
                    } else {
                        addParentVar(indent: indentBy)
                    }
                    lines += [ "}"]
                }
            } else {
                addParentVar()
            }
        case .root:
            lines.append("}")
        default:
            break
        }
        return lines.map{indent + $0}

    }
}

func parseAST(source: String) throws -> [AST] {
    var document: [AST] = []
    var astStack: [AST] = [] {
        willSet {
            // automatically link as part of the parent
            if let parent = astStack.last, let child = newValue.last, astStack.count + 1 == newValue.count {
                parent.children.append(child)
            }
        }
    }
    for line in source.split(separator: "\n") {
        let trim = line.trimmingCharacters(in: .whitespaces)
        if trim.hasPrefix("//") || trim.isEmpty {
            if astStack.isEmpty {
                document.append(.init(kind: .comment, name: trim))
            } else {
                astStack.last?.children.append(.init(kind: .comment, name: trim))
            }
            continue // a comment
        } else if trim.hasPrefix("!") {
            let code = AST(kind: .code, name: .init(trim.dropFirst().trimmingCharacters(in: .whitespaces)))
            if astStack.isEmpty {
                document.append(code)
            } else {
                astStack.last?.children.append(code)
            }
            continue // verbatim code
        }
        let parts = trim.components(separatedBy: .whitespaces)
        // this to make parsing the parts more like a tokenizer
        var tokenIndex = 0
        var token : String? {
            if tokenIndex < parts.count {
                return parts[tokenIndex]
            } else {
                return nil
            }
        }
        var isAtEOL: Bool {
            tokenIndex >= parts.count
        }
        @discardableResult
        func nextToken() -> String? {
            tokenIndex += 1
            return token
        }
        func nextTokenList() -> String? {
            tokenIndex += 1
            var retval = token
            if retval?.hasPrefix("<") == true {
                retval = retval.map{String($0.dropFirst())}
                while true {
                    tokenIndex += 1
                    if let next = token {
                        retval?.append(" ")
                        if next.hasSuffix(">") == true {
                            retval?.append(String(next.dropLast()))
                            break
                        } else {
                            retval?.append(next)
                        }
                    } else {
                        break
                    }
                }
            }
            return retval
        }
        func rest() -> String {
            guard tokenIndex < parts.count - 1 else {
                return ""
            }
            return .init(parts[(tokenIndex+1)...].joined(separator: " "))
        }
        switch token {
        case "end":
            _ = astStack.popLast()
        case "root":
            guard astStack.isEmpty else {
                throw Errors.rootNodeNotAtRoot
            }
            guard let name = nextToken() else {
                throw Errors.missingNodeName
            }
            let node = AST(kind: .root, name: name)
            document.append(node)
            astStack.append(node)
        case "node":
            guard let name = nextToken() else {
                throw Errors.missingNodeName
            }
            let node: AST
            if let parent = nextTokenList() {
                node = .init(kind: .node(parent: parent), name: name)
            } else {
                node = .init(kind: .node(parent: nil), name: name)
            }
            if astStack.isEmpty {
                document.append(node)
            }
            astStack.append(node)
        case "leaf":
            guard let name = nextToken() else {
                throw Errors.missingNodeName
            }
            guard let type = nextToken() else {
                throw Errors.missingLeafType
            }
            astStack.last?.children.append(.init(kind: .leaf(type), name: name))
        case "subscript":
            guard let name = nextToken() else {
                throw Errors.missingNodeName
            }
            guard let type = nextToken() else {
                throw Errors.missingLeafType
            }
            astStack.last?.children.append(.init(kind: .subscript(type), name: name))
        case "var":
            guard let name = nextToken() else {
                throw Errors.missingNodeName
            }
            astStack.last?.children.append(.init(kind: .var, name: name))
        case "key":
            guard let name = nextToken() else {
                throw Errors.missingNodeName
            }
            guard let type = nextToken() else {
                throw Errors.missingLeafType
            }
            astStack.last?.children.append(.init(kind: .key(type), name: name))
        case "enum":
            guard let name = nextToken() else {
                throw Errors.missingNodeName
            }
            astStack.append(.init(kind: .enum, name: name))
        case "case":
            guard let name = nextToken() else {
                throw Errors.missingNodeName
            }
            astStack.last?.children.append(.init(kind: .case(nextToken()), name: name))
        case "action":
            guard let name = nextToken() else {
                throw Errors.missingNodeName
            }
            astStack.last?.children.append(.init(kind: .action, name: name))
        default:
            throw Errors.syntaxError
        }
    }
    return document
}

do {
    let source = try String(contentsOfFile: inputFileName)
    let destURL = URL(fileURLWithPath: outputFolder, isDirectory: false)
    try FileManager.default.createDirectory(at: destURL.deletingLastPathComponent(), withIntermediateDirectories: true)
    let document = try parseAST(source: source)
    var output = ""
    for root in document {
        switch root.kind {
        case .node, .root:
            print("=========\(root.name)=======")
//            print(try root.generate())
            output.append(try root.generate())
            output.append("\n")
//            try root.save(destURL: destURL)
        default:
            break
        }
    }
    try output.data(using: .utf8)?.write(to: destURL)
} catch {
    print("Error: \(error)")
    exit(99)
}
    
